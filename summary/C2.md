# Chapter 2 - Variables and Basic Types

Types are fundamental to any program: They tell us what our data
mean and what operations we can perform on those data.

C++ defines several primitive types (characters, integers, floating-point numbers, etc.)
and provides mechanisms that let us define our own data types. This
chapter covers the built-in types and begins our coverage of how C++ supports more complicated types.


## Primitive Built-in Types

C++ defines a set of primitive types that include the **arithmetic types** and a special
type named **`void`**. The arithmetic types represent characters, integers, boolean
values, and floating-point numbers. The `void` type has no associated values and
can be used in only a few circumstances, most commonly as the return type for
functions that do not return a value.

### Arithmetic Types

The arithmetic types are divided into two categories: **integral types** (which include
character and boolean types) and floating-point types.

The `bool` type represents the truth values `true` and `false`.

The basic character type is `char`. A `char` is guaranteed to be big enough to
hold numeric values corresponding to the characters in the machine’s basic character
set. That is, a `char` is the same size as a single machine byte.

The remaining character types—`wchar_t`, `char16_t`, and `char32_t`—are
used for extended character sets. The `wchar_t` type is guaranteed to be large
enough to hold any character in the machine’s largest extended character set. The
types `char16_t` and `char32_t` are intended for Unicode characters.

The remaining integral types represent integer values of (potentially) different
sizes. The language guarantees that an `int` will be at least as large as `short`, a
`long` at least as large as an `int`, and `long long` at least as large as `long`.

The floating-point types represent single-, double-, and extended-precision values.
The standard specifies a minimum number of significant digits. Most compilers
provide more precision than the specified minimum.

**Signed and Unsigned Types**

Except for `bool` and the extended character types, the integral typesmay be **signed**
or **unsigned**. A signed type represents negative or positive numbers (including
zero); an unsigned type represents only values greater than or equal to zero.

The types `int`, `short`, `long`, and `long long` are all signed. We obtain the
corresponding unsigned type by adding unsigned to the type, such as `unsigned
long`.

> **ADVICE: DECIDING WHICH TYPE TO USE**

> **Most programmers can (and should) ignore these complexities by restricting the types they
use. A few rules of thumb can be useful in deciding which type to use:**

> * **Use an unsigned type when you know that the values cannot be negative.**

> * **Use `int` for integer arithmetic. `short` is usually too small and, in practice, `long`
often has the same size as `int`. If your data values are larger than the minimum
guaranteed size of an `int`, then use `long long`.**

> * **Do not use plain `char` or `bool` in arithmetic expressions. Use them *only* to hold
characters or truth values. Computations using `char` are especially problematic
because `char` is `signed` on some machines and `unsigned` on others. If you
need a tiny integer, explicitly specify either `signed char` or `unsigned char`.**

> * **Use `double` for floating-point computations; `float` usually does not have
enough precision, and the cost of double-precision calculations versus singleprecision
is negligible. In fact, on some machines, double-precision operations
are faster than single. The precision offered by `long double` usually is unnecessary
and often entails considerable run-time cost.**

### Type Conversions

Among the operations that many types support is the ability to **convert** objects of the given type to other, related types.
Type conversions happen automatically when we use an object of one type where an object of another type is expected.

When we assign one arithmetic type to another:

```
bool b = 42; // b is true
int i = b; // i has value 1
i = 3.14; // i has value 3
double pi = i; // pi has value 3.0
unsigned char c = -1; // assuming 8-bit chars, c has value 255
signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined
```

what happens depends on the range of the values that the types permit:

* When we assign one of the nonbool arithmetic types to a `bool` object, the
result is `false` if the value is 0 and `true` otherwise.

* When we assign a `bool` to one of the other arithmetic types, the resulting
value is 1 if the `bool` is `true` and 0 if the `bool` is `false`.

* When we assign a floating-point value to an object of integral type, the value
is truncated. The value that is stored is the part before the decimal point.

* When we assign an integral value to an object of floating-point type, the fractional
part is zero. Precision may be lost if the integer has more bits than the
floating-point object can accommodate.

* If we assign an out-of-range value to an object of unsigned type, the result is
the remainder of the value modulo the number of values the target type can
hold.

* If we assign an out-of-range value to an object of signed type, the result is
**undefined**. The program might appear to work, it might crash, or it might
produce garbage values.

**Experssions Involving Unsigned Types**

For example, if we use both `unsigned` and `int` values in an arithmetic expression, the
`int` value ordinarily is converted to `unsigned`. Converting an `int` to `unsigned`
executes the same way as if we assigned the `int` to an `unsigned`:

```
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // prints -84
std::cout << u + i << std::endl; // if 32-bit ints, prints 4294967264
```

Converting a negative number to `unsigned` behaves exactly as ifwe had attempted to assign that negative value to an 
`unsigned` object. The value “wraps around” as described above.

Regardless of whether one or both operands are unsigned, if we subtract a
value from an unsigned, we must be sure that the result cannot be negative:

```
unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl; // ok: result is 32
std::cout << u2 - u1 << std::endl; // ok: but the result will wrap around
```

> **CAUTION: DON’T MIX SIGNED AND UNSIGNED TYPES**

> **Expressions that mix signed and unsigned values can yield surprising results when
the signed value is negative. It is essential to remember that signed values are automatically
converted to unsigned.**

### Literals

A value, such as 42, is known as a **literal** because its value self-evident. Every
literal has a type. The form and value of a literal determine its type.

**Integer and Floating-Point Literals**

We can write an integer literal using decimal, octal, or hexadecimal notation. Integer
literals that begin with `0` (zero) are interpreted as octal. Those that begin with
either `0x` or `0X` are interpreted as hexadecimal. For example, we can write the
value `20` in any of the following three ways:

```
20 /* decimal */ 024 /* octal */ 0x14 /* hexadecimal */
```

The type of an integer literal depends on its value and notation. By default, decimal
literals are signed whereas octal and hexadecimal literals can be either signed
or unsigned types. A decimal literal has the smallest type of `int`, `long`, or `long long` 
(i.e., the first type in this list) in which the literal’s value fits. Octal and hexadecimal
literals have the smallest type of `int`, `unsigned int`, `long`, `unsigned long`, `long long`, 
or `unsigned long long` in which the literal’s value fits. It is
an error to use a literal that is too large to fit in the largest related type. There are
no literals of type `short`.

Although integer literals may be stored in signed types, technically speaking,
the value of a decimal literal is never a negative number. The minus sign is an operator that negates 
the value of its (literal) operand.

Floating-point literals include either a decimal point or an exponent specified
using scientific notation. Using scientific notation, the exponent is indicated by
either E or e:

```
3.14159 3.14159E0 0. 0e0 .001
```

**Character and Character String Literals**

A character enclosed within single quotes is a literal of type `char`. Zero ormore
characters enclosed in double quotation marks is a string literal:

```
’a’ // character literal
"Hello World!" // string literal
```

Two string literals that appear adjacent to one another and that are separated
only by spaces, tabs, or newlines are concatenated into a single literal. We use this
form of literal when we need to write a literal that would otherwise be too large to
fit comfortably on a single line:

```
// multiline string literal
std::cout << "a really, really long string literal "
	"that spans two lines" << std::endl;
```

**Escape Sequences**

Some characters, such as backspace or control characters, have no visible image.
Such characters are **nonprintable**. Other characters (single and double quotation
marks, question mark, and backslash) have special meaning in the language. Our
programs cannot use any of these characters directly. Instead, we use an **escape sequence**
to represent such characters. An escape sequence begins with a backslash.
The language defines several escape sequences:

```
newline \n horizontal tab \t alert (bell) \a
vertical tab \v backspace \b double quote \"
backslash \\ question mark \? single quote \’
carriage return \r formfeed \f
```

**Boolean and Pointer Literals**

The words `true` and `false` are literals of type `bool`:

```
bool test = false;
```

## Variables

A *variable* provides us with named storage that our programs can manipulate.
Each variable in C++ has a type. The type determines the size and layout of the
variable’s memory, the range of values that can be stored within that memory, and
the set of operations that can be applied to the variable.

### Variable Definitions

A simple variable definition consists of a **type specifier**, followed by a list of one or
more variable names separated by commas, and ends with a semicolon. Each name
in the list has the type defined by the type specifier. A definition may (optionally)
provide an initial value for one or more of the names it defines:

```
int sum = 0, value, // sum, value, and units_sold have type int
units_sold = 0; // sum and units_sold have initial value 0
Sales_item item; // item has type Sales_item
// string is a library type, representing a variable-length sequence of characters
std::string book("0-201-78345-X"); // book initialized from string literal
```

**Initializer**

An object that is **initialized** gets the specified value at the moment it is created.
The values used to initialize a variable can be arbitrarily complicated expressions.
When a definition defines two or more variables, the name of each object becomes
visible immediately. Thus, it is possible to initialize a variable to the value of one
defined earlier in the same definition.

```
// ok: price is defined and initialized before it is used to initialize discount
double price = 109.99, discount = price * 0.16;
// ok: call applyDiscount and use the return value to initialize salePrice
double salePrice = applyDiscount(price, discount);
```

> Initialization is not assignment. Initialization happens when a variable
is given a value when it is created. Assignment obliterates an object’s
current value and replaces that value with a new one.

**List Initialization**

One way in which initialization is a complicated topic is that the language defines
several different forms of initialization.

```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

The generalized use of curly braces for initialization was introduced as part of
the new standard, this form of initialization is referred to as **list initialization**.

**Default Initialization**

When we define a variable without an initializer, the variable is **default initialized**.
Such variables are given the “default” value.

> Uninitialized objects of built-in type defined inside a function body
have undefined value. Objects of class type that we do not explicitly
initialize have a value that is defined by the class.

> **CAUTION: UNINITIALIZED VARIABLES CAUSE RUN-TIME PROBLEMS**

> **We recommend initializing every object of built-in type. It is not always
necessary, but it is easier and safer to provide an initializer until you can
be certain it is safe to omit the initializer.**

### Variable Declarations and Definitions

To support separate compilation, C++ distinguishes between declarations and
definitions. A **declaration** makes a name known to the program. A file that wants
to use a name defined elsewhere includes a declaration for that name. A **definition**
creates the associated entity.

To obtain a declaration that is not also a definition, we add the `extern` keyword
and may not provide an explicit initializer:

```
extern int i; // declares but does not define i
int j; // declares and defines j
```

Any declaration that includes an explicit initializer is a definition. We can provide
an initializer on a variable defined as `extern`, but doing so overrides the
extern. An `extern` that has an initializer is a definition:

```
extern double pi = 3.1416; // definition
```

> Variables must be defined exactly once but can be declared many times.
























































