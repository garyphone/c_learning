# Chapter 2 - Variables and Basic Types

Types are fundamental to any program: They tell us what our data
mean and what operations we can perform on those data.

C++ defines several primitive types (characters, integers, floating-point numbers, etc.)
and provides mechanisms that let us define our own data types. This
chapter covers the built-in types and begins our coverage of how C++ supports more complicated types.


## Primitive Built-in Types

C++ defines a set of primitive types that include the **arithmetic types** and a special
type named **`void`**. The arithmetic types represent characters, integers, boolean
values, and floating-point numbers. The `void` type has no associated values and
can be used in only a few circumstances, most commonly as the return type for
functions that do not return a value.

### Arithmetic Types

The arithmetic types are divided into two categories: **integral types** (which include
character and boolean types) and floating-point types.

The `bool` type represents the truth values `true` and `false`.

The basic character type is `char`. A `char` is guaranteed to be big enough to
hold numeric values corresponding to the characters in the machine’s basic character
set. That is, a `char` is the same size as a single machine byte.

The remaining character types—`wchar_t`, `char16_t`, and `char32_t`—are
used for extended character sets. The `wchar_t` type is guaranteed to be large
enough to hold any character in the machine’s largest extended character set. The
types `char16_t` and `char32_t` are intended for Unicode characters.

The remaining integral types represent integer values of (potentially) different
sizes. The language guarantees that an `int` will be at least as large as `short`, a
`long` at least as large as an `int`, and `long long` at least as large as `long`.

The floating-point types represent single-, double-, and extended-precision values.
The standard specifies a minimum number of significant digits. Most compilers
provide more precision than the specified minimum.

**Signed and Unsigned Types**

Except for `bool` and the extended character types, the integral typesmay be **signed**
or **unsigned**. A signed type represents negative or positive numbers (including
zero); an unsigned type represents only values greater than or equal to zero.

The types `int`, `short`, `long`, and `long long` are all signed. We obtain the
corresponding unsigned type by adding unsigned to the type, such as `unsigned
long`.

> **ADVICE: DECIDING WHICH TYPE TO USE**

> **Most programmers can (and should) ignore these complexities by restricting the types they
use. A few rules of thumb can be useful in deciding which type to use:**

> * **Use an unsigned type when you know that the values cannot be negative.**

> * **Use `int` for integer arithmetic. `short` is usually too small and, in practice, `long`
often has the same size as `int`. If your data values are larger than the minimum
guaranteed size of an `int`, then use `long long`.**

> * **Do not use plain `char` or `bool` in arithmetic expressions. Use them *only* to hold
characters or truth values. Computations using `char` are especially problematic
because `char` is `signed` on some machines and `unsigned` on others. If you
need a tiny integer, explicitly specify either `signed char` or `unsigned char`.**

> * **Use `double` for floating-point computations; `float` usually does not have
enough precision, and the cost of double-precision calculations versus singleprecision
is negligible. In fact, on some machines, double-precision operations
are faster than single. The precision offered by `long double` usually is unnecessary
and often entails considerable run-time cost.**

### Type Conversions

Among the operations that many types support is the ability to **convert** objects of the given type to other, related types.
Type conversions happen automatically when we use an object of one type where an object of another type is expected.

When we assign one arithmetic type to another:

```
bool b = 42; // b is true
int i = b; // i has value 1
i = 3.14; // i has value 3
double pi = i; // pi has value 3.0
unsigned char c = -1; // assuming 8-bit chars, c has value 255
signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined
```

what happens depends on the range of the values that the types permit:

* When we assign one of the nonbool arithmetic types to a `bool` object, the
result is `false` if the value is 0 and `true` otherwise.

* When we assign a `bool` to one of the other arithmetic types, the resulting
value is 1 if the `bool` is `true` and 0 if the `bool` is `false`.

* When we assign a floating-point value to an object of integral type, the value
is truncated. The value that is stored is the part before the decimal point.

* When we assign an integral value to an object of floating-point type, the fractional
part is zero. Precision may be lost if the integer has more bits than the
floating-point object can accommodate.

* If we assign an out-of-range value to an object of unsigned type, the result is
the remainder of the value modulo the number of values the target type can
hold.

* If we assign an out-of-range value to an object of signed type, the result is
**undefined**. The program might appear to work, it might crash, or it might
produce garbage values.

**Experssions Involving Unsigned Types**

For example, if we use both `unsigned` and `int` values in an arithmetic expression, the
`int` value ordinarily is converted to `unsigned`. Converting an `int` to `unsigned`
executes the same way as if we assigned the `int` to an `unsigned`:

```
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // prints -84
std::cout << u + i << std::endl; // if 32-bit ints, prints 4294967264
```

Converting a negative number to `unsigned` behaves exactly as ifwe had attempted to assign that negative value to an 
`unsigned` object. The value “wraps around” as described above.

Regardless of whether one or both operands are unsigned, if we subtract a
value from an unsigned, we must be sure that the result cannot be negative:

```
unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl; // ok: result is 32
std::cout << u2 - u1 << std::endl; // ok: but the result will wrap around
```

> **CAUTION: DON’T MIX SIGNED AND UNSIGNED TYPES**

> **Expressions that mix signed and unsigned values can yield surprising results when
the signed value is negative. It is essential to remember that signed values are automatically
converted to unsigned.**

### Literals

A value, such as 42, is known as a **literal** because its value self-evident. Every
literal has a type. The form and value of a literal determine its type.

**Integer and Floating-Point Literals**

We can write an integer literal using decimal, octal, or hexadecimal notation. Integer
literals that begin with `0` (zero) are interpreted as octal. Those that begin with
either `0x` or `0X` are interpreted as hexadecimal. For example, we can write the
value `20` in any of the following three ways:

```
20 /* decimal */ 024 /* octal */ 0x14 /* hexadecimal */
```

The type of an integer literal depends on its value and notation. By default, decimal
literals are signed whereas octal and hexadecimal literals can be either signed
or unsigned types. A decimal literal has the smallest type of `int`, `long`, or `long long` 
(i.e., the first type in this list) in which the literal’s value fits. Octal and hexadecimal
literals have the smallest type of `int`, `unsigned int`, `long`, `unsigned long`, `long long`, 
or `unsigned long long` in which the literal’s value fits. It is
an error to use a literal that is too large to fit in the largest related type. There are
no literals of type `short`.

Although integer literals may be stored in signed types, technically speaking,
the value of a decimal literal is never a negative number. The minus sign is an operator that negates 
the value of its (literal) operand.

Floating-point literals include either a decimal point or an exponent specified
using scientific notation. Using scientific notation, the exponent is indicated by
either E or e:

```
3.14159 3.14159E0 0. 0e0 .001
```

**Character and Character String Literals**

A character enclosed within single quotes is a literal of type `char`. Zero ormore
characters enclosed in double quotation marks is a string literal:

```
’a’ // character literal
"Hello World!" // string literal
```

Two string literals that appear adjacent to one another and that are separated
only by spaces, tabs, or newlines are concatenated into a single literal. We use this
form of literal when we need to write a literal that would otherwise be too large to
fit comfortably on a single line:

```
// multiline string literal
std::cout << "a really, really long string literal "
	"that spans two lines" << std::endl;
```

**Escape Sequences**

Some characters, such as backspace or control characters, have no visible image.
Such characters are **nonprintable**. Other characters (single and double quotation
marks, question mark, and backslash) have special meaning in the language. Our
programs cannot use any of these characters directly. Instead, we use an **escape sequence**
to represent such characters. An escape sequence begins with a backslash.
The language defines several escape sequences:

```
newline \n horizontal tab \t alert (bell) \a
vertical tab \v backspace \b double quote \"
backslash \\ question mark \? single quote \’
carriage return \r formfeed \f
```

**Boolean and Pointer Literals**

The words `true` and `false` are literals of type `bool`:

```
bool test = false;
```























































